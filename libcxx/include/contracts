#ifndef _LIBCPP_CONTRACTS
#define _LIBCPP_CONTRACTS

#include <__config>
#include <version>
#include <source_location>

namespace std::contracts {

enum class assertion_kind : unsigned char {
  __unknown = 0,
  pre = 1,
  post = 2,
  assert = 3
};
using _AssertKind = assertion_kind;
enum class evaluation_semantic : unsigned char {
  __unknown = 0,
  enforce = 1,
  observe = 2
};
using _EvaluationSemantic = evaluation_semantic;
enum class detection_mode : unsigned char {
  __unknown = 0,
  predicate_false = 1,
  evaluation_exception = 2
};
using _DetectionMode = detection_mode;

struct _ContractViolationImpl;

class contract_violation {
// no userâˆ’accessible constructor
  friend struct _ContractViolationImpl;

public:
  ~contract_violation() = default;
  contract_violation(const contract_violation&) = delete;
  contract_violation& operator=(const contract_violation&) = delete;

  _LIBCPP_EXPORTED_FROM_ABI std::source_location location() const noexcept;
  _LIBCPP_EXPORTED_FROM_ABI const char* comment() const noexcept;
  _LIBCPP_EXPORTED_FROM_ABI _DetectionMode detection_mode() const noexcept;
  _LIBCPP_EXPORTED_FROM_ABI assertion_kind kind() const noexcept;
  _LIBCPP_EXPORTED_FROM_ABI evaluation_semantic semantic() const noexcept;

private:
  explicit contract_violation(const _ContractViolationImpl *impl) noexcept
    : __pimpl_(impl) {}

  const _ContractViolationImpl *__pimpl_;
};



_LIBCPP_EXPORTED_FROM_ABI void invoke_default_contract_violation_handler(const contract_violation&) noexcept;


} // namespace std::contracts

_LIBCPP_WEAK void handle_contract_violation(const std::contracts::contract_violation&);


#endif // _LIBCPP_CONTRACTS
